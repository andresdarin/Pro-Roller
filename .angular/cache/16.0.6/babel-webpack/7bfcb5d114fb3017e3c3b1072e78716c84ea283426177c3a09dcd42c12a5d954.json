{"ast":null,"code":"import { CommonModule } from '@angular/common';\nimport { Injectable, EventEmitter, Component, Renderer2, ViewChild, Input, Output, Directive, Host, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Attribute, Pipe, HostListener, NgModule } from '@angular/core';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatSlider, MAT_SLIDER_VALUE_ACCESSOR, MatSliderModule } from '@angular/material/slider';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass EventService {\n  constructor() {}\n  /**\r\n   * @param {?} renderer\r\n   * @param {?} events\r\n   * @return {?}\r\n   */\n  addEvents(renderer, events) {\n    for (const event of events) {\n      event.dispose = renderer.listen(event.element, event.name,\n      /**\r\n      * @param {?} newEvent\r\n      * @return {?}\r\n      */\n      newEvent => event.callback(newEvent));\n    }\n  }\n  /**\r\n   * @param {?} events\r\n   * @return {?}\r\n   */\n  removeEvents(events) {\n    for (const event of events) {\n      if (event.dispose) {\n        event.dispose();\n      }\n    }\n  }\n}\nEventService.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\nEventService.ctorParameters = () => [];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVideoComponent {\n  /**\r\n   * @param {?} renderer\r\n   * @param {?} evt\r\n   */\n  constructor(renderer, evt) {\n    this.renderer = renderer;\n    this.evt = evt;\n    this.src = null;\n    this.title = null;\n    this.autoplay = false;\n    this.preload = true;\n    this.loop = false;\n    this.quality = true;\n    this.fullscreen = true;\n    this.playsinline = false;\n    this.showFrameByFrame = false;\n    this.fps = 29.97;\n    this.download = false;\n    this.color = \"primary\";\n    this.spinner = \"spin\";\n    this.poster = null;\n    this.keyboard = true;\n    this.overlay = null;\n    this.muted = false;\n    this.mutedChange = new EventEmitter();\n    this.timeChange = new EventEmitter();\n    this.playing = false;\n    this.isFullscreen = false;\n    this.videoLoaded = false;\n    this.isMouseMoving = false;\n    this.isMouseMovingTimeout = 2000;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get time() {\n    return this.getVideoTag().currentTime;\n  }\n  /**\r\n   * @param {?} val\r\n   * @return {?}\r\n   */\n  set time(val) {\n    /** @type {?} */\n    const video = this.getVideoTag();\n    if (video && val) {\n      if (val > video.duration) {\n        val = video.duration;\n      }\n      if (val < 0) {\n        val = 0;\n      }\n      if (Math.abs(val - video.currentTime) > 0.0001) {\n        video.currentTime = val;\n      }\n      if (Math.abs(this.lastTime - video.currentTime) > 0.0001) {\n        setTimeout(\n        /**\r\n        * @return {?}\r\n        */\n        () => this.timeChange.emit(video.currentTime), 0);\n        this.lastTime = video.currentTime;\n      }\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngAfterViewInit() {\n    this.events = [{\n      element: this.video.nativeElement,\n      name: \"loadstart\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoLoaded = false,\n      dispose: null\n    }, {\n      element: this.video.nativeElement,\n      name: \"loadedmetadata\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.evLoadedMetadata(event),\n      dispose: null\n    }, {\n      element: this.video.nativeElement,\n      name: \"error\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => console.error(\"Unhandled Video Error\", event),\n      dispose: null\n    }, {\n      element: this.video.nativeElement,\n      name: \"contextmenu\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => event.preventDefault(),\n      dispose: null\n    }, {\n      element: this.video.nativeElement,\n      name: \"timeupdate\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.evTimeUpdate(event),\n      dispose: null\n    }, {\n      element: this.player.nativeElement,\n      name: \"mousemove\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.evMouseMove(event),\n      dispose: null\n    }];\n    this.video.nativeElement.onloadeddata =\n    /**\r\n    * @return {?}\r\n    */\n    () => this.videoLoaded = true;\n    this.evt.addEvents(this.renderer, this.events);\n    this.setVideoSrc(this.src);\n  }\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n  ngOnChanges(changes) {\n    if (changes.src) {\n      this.setVideoSrc(this.src);\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnDestroy() {\n    this.video.nativeElement.onloadeddata = null;\n    this.evt.removeEvents(this.events);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  load() {\n    if (this.video && this.video.nativeElement) {\n      this.video.nativeElement.load();\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  getVideoTag() {\n    return this.video && this.video.nativeElement ? /** @type {?} */this.video.nativeElement : null;\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  evLoadedMetadata(event) {\n    this.videoWidth = this.video.nativeElement.videoWidth;\n    this.videoHeight = this.video.nativeElement.videoHeight;\n    this.videoLoaded = true;\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  evMouseMove(event) {\n    this.isMouseMoving = true;\n    clearTimeout(this.isMouseMovingTimer);\n    this.isMouseMovingTimer = setTimeout(\n    /**\r\n    * @return {?}\r\n    */\n    () => {\n      this.isMouseMoving = false;\n    }, this.isMouseMovingTimeout);\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  evTimeUpdate(event) {\n    this.time = this.getVideoTag().currentTime;\n  }\n  /**\r\n   * @param {?} activeClass\r\n   * @param {?} inactiveClass\r\n   * @return {?}\r\n   */\n  getOverlayClass(activeClass, inactiveClass) {\n    if (this.overlay === null) {\n      return !this.playing || this.isMouseMoving ? activeClass : inactiveClass;\n    } else {\n      return this.overlay ? activeClass : inactiveClass;\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {?} src\r\n   * @return {?}\r\n   */\n  setVideoSrc(src) {\n    if (this.srcObjectURL) {\n      URL.revokeObjectURL(this.srcObjectURL);\n      this.srcObjectURL = null;\n    }\n    if (!this.video || !this.video.nativeElement) {\n      return;\n    }\n    if (!src) {\n      this.video.nativeElement.src = null;\n      if (\"srcObject\" in HTMLVideoElement.prototype) {\n        this.video.nativeElement.srcObject = new MediaStream();\n      }\n    } else if (typeof src === \"string\") {\n      this.video.nativeElement.src = src;\n    } else if (\"srcObject\" in HTMLVideoElement.prototype) {\n      this.video.nativeElement.srcObject = src;\n    } else {\n      this.srcObjectURL = URL.createObjectURL(src);\n      this.video.nativeElement.src = this.srcObjectURL;\n    }\n    this.video.nativeElement.muted = this.muted;\n  }\n}\nMatVideoComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-video\",\n    template: \"<div #player class=\\\"videoplayer\\\" [ngClass]=\\\"getOverlayClass('show-mouse', 'hide-mouse')\\\">\\n  <div class=\\\"header\\\" *ngIf=\\\"title\\\" [ngClass]=\\\"getOverlayClass('visible', 'hidden')\\\">\\n    {{ title }}\\n  </div>\\n\\n  <video\\n    #video\\n    class=\\\"video\\\"\\n    [attr.autoplay]=\\\"autoplay ? true : null\\\"\\n    [preload]=\\\"preload ? 'auto' : 'metadata'\\\"\\n    [attr.poster]=\\\"poster ? poster : null\\\"\\n    [attr.loop]=\\\"loop ? loop : null\\\"\\n    [attr.playsinline]=\\\"playsinline ? true : null\\\"\\n  >\\n    <ng-content select=\\\"source\\\"></ng-content>\\n    <ng-content select=\\\"track\\\"></ng-content>\\n    This browser does not support HTML5 video.\\n  </video>\\n\\n  <div class=\\\"controls\\\" *ngIf=\\\"videoLoaded\\\" [ngClass]=\\\"getOverlayClass('visible', 'hidden')\\\">\\n    <div class=\\\"progress\\\">\\n      <mat-seek-progress-control [color]=\\\"color\\\" [video]=\\\"video\\\"></mat-seek-progress-control>\\n    </div>\\n\\n    <div class=\\\"menu\\\">\\n      <div class=\\\"left\\\">\\n        <mat-play-button (playChanged)=\\\"playing = $event\\\" [video]=\\\"video\\\" [keyboard]=\\\"keyboard\\\"> </mat-play-button>\\n\\n        <mat-frame-by-frame-control *ngIf=\\\"showFrameByFrame\\\" [video]=\\\"video\\\" [fps]=\\\"fps\\\"></mat-frame-by-frame-control>\\n\\n        <mat-volume-control\\n          [muted]=\\\"muted\\\"\\n          (mutedChanged)=\\\"muted = $event; mutedChange.emit(muted)\\\"\\n          [color]=\\\"color\\\"\\n          [video]=\\\"video\\\"\\n          [keyboard]=\\\"keyboard\\\"\\n        >\\n        </mat-volume-control>\\n\\n        <mat-time-control [video]=\\\"video\\\"></mat-time-control>\\n      </div>\\n\\n      <div class=\\\"right\\\">\\n        <mat-quality-control *ngIf=\\\"quality\\\" [video]=\\\"video\\\"></mat-quality-control>\\n\\n        <mat-download-button *ngIf=\\\"download\\\" [title]=\\\"title\\\" [video]=\\\"video\\\"></mat-download-button>\\n\\n        <mat-fullscreen-button\\n          *ngIf=\\\"fullscreen\\\"\\n          (fullscreenChanged)=\\\"isFullscreen = $event\\\"\\n          [player]=\\\"player\\\"\\n          [keyboard]=\\\"keyboard\\\"\\n        ></mat-fullscreen-button>\\n      </div>\\n    </div>\\n  </div>\\n\\n  <mat-video-spinner [spinner]=\\\"spinner\\\" [video]=\\\"video\\\"></mat-video-spinner>\\n</div>\\n\",\n    styles: [\".videoplayer{font-family:Roboto,\\\"Helvetica Neue\\\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video{display:block;width:100%;height:100%;z-index:0}.controls{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls .progress{height:26px}.controls .menu{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls .menu .left{justify-content:flex-start}.controls .menu .right{justify-content:flex-end}.visible{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse{cursor:default}.hide-mouse{cursor:none}\", \"@font-face{font-family:\\\"Material Icons\\\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format(\\\"woff2\\\")}::ng-deep.material-icons{font-family:\\\"Material Icons\\\";font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:\\\"liga\\\";-webkit-font-feature-settings:\\\"liga\\\";-webkit-font-smoothing:antialiased}\"]\n  }]\n}];\n/** @nocollapse */\nMatVideoComponent.ctorParameters = () => [{\n  type: Renderer2\n}, {\n  type: EventService\n}];\nMatVideoComponent.propDecorators = {\n  player: [{\n    type: ViewChild,\n    args: [\"player\", {\n      static: false\n    }]\n  }],\n  video: [{\n    type: ViewChild,\n    args: [\"video\", {\n      static: false\n    }]\n  }],\n  src: [{\n    type: Input\n  }],\n  title: [{\n    type: Input\n  }],\n  autoplay: [{\n    type: Input\n  }],\n  preload: [{\n    type: Input\n  }],\n  loop: [{\n    type: Input\n  }],\n  quality: [{\n    type: Input\n  }],\n  fullscreen: [{\n    type: Input\n  }],\n  playsinline: [{\n    type: Input\n  }],\n  showFrameByFrame: [{\n    type: Input\n  }],\n  fps: [{\n    type: Input\n  }],\n  download: [{\n    type: Input\n  }],\n  color: [{\n    type: Input\n  }],\n  spinner: [{\n    type: Input\n  }],\n  poster: [{\n    type: Input\n  }],\n  keyboard: [{\n    type: Input\n  }],\n  overlay: [{\n    type: Input\n  }],\n  muted: [{\n    type: Input\n  }],\n  mutedChange: [{\n    type: Output\n  }],\n  timeChange: [{\n    type: Output\n  }],\n  time: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVideoSourceDirective {\n  /**\r\n   * @param {?} matVideoComponent\r\n   * @param {?} el\r\n   */\n  constructor(matVideoComponent, el) {\n    this.matVideoComponent = matVideoComponent;\n    this.el = el;\n    this.src = null;\n    this.type = null;\n    this.init = true;\n    this.video = matVideoComponent;\n    this.source = el.nativeElement;\n    this.init = false;\n  }\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n  ngOnChanges(changes) {\n    this.source.src = this.src;\n    this.source.type = this.type;\n    if (!this.init) {\n      this.video.load();\n    }\n  }\n}\nMatVideoSourceDirective.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"[matVideoSource]\"\n  }]\n}];\n/** @nocollapse */\nMatVideoSourceDirective.ctorParameters = () => [{\n  type: MatVideoComponent,\n  decorators: [{\n    type: Host\n  }]\n}, {\n  type: ElementRef\n}];\nMatVideoSourceDirective.propDecorators = {\n  src: [{\n    type: Input\n  }],\n  type: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVideoTrackDirective {\n  /**\r\n   * @param {?} matVideoComponent\r\n   * @param {?} el\r\n   */\n  constructor(matVideoComponent, el) {\n    this.matVideoComponent = matVideoComponent;\n    this.el = el;\n    this.src = null;\n    this.kind = null;\n    this.srclang = null;\n    this.label = null;\n    this.init = true;\n    this.video = matVideoComponent;\n    this.track = el.nativeElement;\n    this.init = false;\n  }\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n  ngOnChanges(changes) {\n    this.track.src = this.src;\n    this.track.kind = this.kind;\n    this.track.srclang = this.srclang;\n    this.track.label = this.label;\n    if (!this.init) {\n      this.video.load();\n    }\n  }\n}\nMatVideoTrackDirective.decorators = [{\n  type: Directive,\n  args: [{\n    selector: \"[matVideoTrack]\"\n  }]\n}];\n/** @nocollapse */\nMatVideoTrackDirective.ctorParameters = () => [{\n  type: MatVideoComponent,\n  decorators: [{\n    type: Host\n  }]\n}, {\n  type: ElementRef\n}];\nMatVideoTrackDirective.propDecorators = {\n  src: [{\n    type: Input\n  }],\n  kind: [{\n    type: Input\n  }],\n  srclang: [{\n    type: Input\n  }],\n  label: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/**\r\n * Counter used to generate unique IDs for progress bars.\r\n * @type {?}\r\n */\nlet sliderprogressbarId = 0;\nclass MatSliderProgressBarComponent extends MatSlider {\n  /**\r\n   * @param {?} elementRef\r\n   * @param {?} focusMonitor\r\n   * @param {?} changeDetectorRef\r\n   * @param {?} dir\r\n   * @param {?} tabIndex\r\n   */\n  constructor(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {\n    super(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex);\n    this.mode = \"buffer\";\n    this.value = 0;\n    this.pBufferValue = 0;\n    /**\r\n     * The id of the progress bar.\r\n     */\n    this.sliderprogressbarId = `mat-slider-progress-bar-${sliderprogressbarId++}`;\n    this.tabIndex = parseInt(tabIndex, 10) || 0;\n  }\n  /**\r\n   * Buffer value of the progress bar. Defaults to zero.\r\n   * @return {?}\r\n   */\n  get bufferValue() {\n    return this.pBufferValue;\n  }\n  /**\r\n   * @param {?} v\r\n   * @return {?}\r\n   */\n  set bufferValue(v) {\n    this.pBufferValue = clamp(v || 0);\n  }\n  /**\r\n   * CSS styles for the track fill element.\r\n   * @return {?}\r\n   */\n  get _trackBufferStyles() {\n    if (this.mode === \"buffer\") {\n      /** @type {?} */\n      const axis = this.vertical ? \"Y\" : \"X\";\n      return {\n        transform: `translate${axis}(0px) scale${axis}(${this.pBufferValue / 100})`\n      };\n    }\n  }\n}\nMatSliderProgressBarComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-slider-progress-bar\",\n    template: \"<div class=\\\"mat-slider-wrapper\\\" #sliderWrapper>\\r\\n  <div class=\\\"mat-slider-track-wrapper\\\">\\r\\n    <svg width=\\\"100%\\\" height=\\\"2\\\" focusable=\\\"false\\\" class=\\\"mat-slider-progress-background\\\">\\r\\n      <defs>\\r\\n        <pattern [id]=\\\"sliderprogressbarId\\\" x=\\\"2.5\\\" y=\\\"0\\\" width=\\\"5\\\" height=\\\"2.5\\\" patternUnits=\\\"userSpaceOnUse\\\">\\r\\n          <circle cx=\\\"1.25\\\" cy=\\\"1.25\\\" r=\\\"1.25\\\" />\\r\\n        </pattern>\\r\\n      </defs>\\r\\n      <rect [attr.fill]=\\\"'url(#' + sliderprogressbarId + ')'\\\" width=\\\"100%\\\" height=\\\"100%\\\" />\\r\\n    </svg>\\r\\n    <div class=\\\"mat-slider-track-fill mat-slider-track-buffer\\\" [ngStyle]=\\\"_trackBufferStyles\\\"></div>\\r\\n    <div class=\\\"mat-slider-track-fill\\\" [ngStyle]=\\\"_trackFillStyles\\\"></div>\\r\\n  </div>\\r\\n  <div class=\\\"mat-slider-ticks-container\\\" [ngStyle]=\\\"_ticksContainerStyles\\\">\\r\\n    <div class=\\\"mat-slider-ticks\\\" [ngStyle]=\\\"_ticksStyles\\\"></div>\\r\\n  </div>\\r\\n  <div class=\\\"mat-slider-thumb-container\\\" [ngStyle]=\\\"_thumbContainerStyles\\\">\\r\\n    <div class=\\\"mat-slider-focus-ring\\\"></div>\\r\\n    <div class=\\\"mat-slider-thumb\\\"></div>\\r\\n    <div class=\\\"mat-slider-thumb-label\\\">\\r\\n      <span class=\\\"mat-slider-thumb-label-text\\\">{{ displayValue }}</span>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\\r\\n\",\n    providers: [MAT_SLIDER_VALUE_ACCESSOR],\n    host: {\n      \"(focus)\": \"_onFocus()\",\n      \"(blur)\": \"_onBlur()\",\n      \"(click)\": 'this[\"_onClick\"] ? this[\"_onClick\"]($event) : null',\n      // Angular 5/6 support\n      \"(mousedown)\": 'this[\"_onMousedown\"] ? this[\"_onMousedown\"]($event) : null',\n      // Angular 7 support\n      \"(keydown)\": \"_onKeydown($event)\",\n      \"(keyup)\": \"_onKeyup()\",\n      \"(mouseenter)\": \"_onMouseenter()\",\n      \"(slide)\": \"_onSlide($event)\",\n      \"(slideend)\": \"_onSlideEnd()\",\n      \"(slidestart)\": \"_onSlideStart($event)\",\n      class: \"mat-slider\",\n      role: \"slider\",\n      \"[tabIndex]\": \"tabIndex\",\n      \"[attr.aria-disabled]\": \"disabled\",\n      \"[attr.aria-valuemax]\": \"max\",\n      \"[attr.aria-valuemin]\": \"min\",\n      \"[attr.aria-valuenow]\": \"value\",\n      \"[attr.aria-orientation]\": 'vertical ? \"vertical\" : \"horizontal\"',\n      \"[class.mat-slider-disabled]\": \"disabled\",\n      \"[class.mat-slider-has-ticks]\": \"tickInterval\",\n      \"[class.mat-slider-horizontal]\": \"!vertical\",\n      \"[class.mat-slider-axis-inverted]\": \"_invertAxis\",\n      \"[class.mat-slider-sliding]\": \"_isSliding\",\n      \"[class.mat-slider-thumb-label-showing]\": \"thumbLabel\",\n      \"[class.mat-slider-vertical]\": \"vertical\",\n      \"[class.mat-slider-min-value]\": \"_isMinValue\",\n      \"[class.mat-slider-hide-last-tick]\": \"disabled || _isMinValue && _thumbGap && _invertAxis\"\n    },\n    inputs: [\"disabled\", \"color\", \"tabIndex\"],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    styles: [\":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}\"]\n  }]\n}];\n/** @nocollapse */\nMatSliderProgressBarComponent.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: FocusMonitor\n}, {\n  type: ChangeDetectorRef\n}, {\n  type: Directionality,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: String,\n  decorators: [{\n    type: Attribute,\n    args: [\"tabindex\"]\n  }]\n}];\nMatSliderProgressBarComponent.propDecorators = {\n  mode: [{\n    type: Input\n  }],\n  value: [{\n    type: Input\n  }],\n  bufferValue: [{\n    type: Input\n  }]\n};\n/**\r\n * Clamps a value to be between two numbers, by default 0 and 100.\r\n * @param {?} v\r\n * @param {?=} min\r\n * @param {?=} max\r\n * @return {?}\r\n */\nfunction clamp(v, min = 0, max = 100) {\n  return Math.max(min, Math.min(max, v));\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass SecondsToTimePipe {\n  constructor() {\n    this.times = {\n      year: 31557600,\n      month: 2629746,\n      day: 86400,\n      hour: 3600\n    };\n  }\n  /**\r\n   * @param {?} seconds\r\n   * @return {?}\r\n   */\n  transform(seconds) {\n    if (!seconds) {\n      return \"0:00\";\n    } else {\n      /** @type {?} */\n      let timeString = \"\";\n      for (const key in this.times) {\n        if (Math.floor(seconds / this.times[key]) > 0) {\n          timeString += Math.floor(seconds / this.times[key]).toString() + \":\";\n          seconds = seconds - this.times[key] * Math.floor(seconds / this.times[key]);\n        }\n      }\n      timeString += Math.floor(seconds / 60).toString() + \":\";\n      seconds = seconds - 60 * Math.floor(seconds / 60);\n      if (Math.floor(seconds) < 10) {\n        timeString += \"0\";\n      }\n      timeString += Math.floor(seconds).toString();\n      return timeString;\n    }\n  }\n}\nSecondsToTimePipe.decorators = [{\n  type: Pipe,\n  args: [{\n    name: \"secondsToTime\"\n  }]\n}];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass FullscreenService {\n  constructor() {\n    this.fnMap = [\n    // Object keys\n    [\"requestFullscreen\", \"exitFullscreen\", \"fullscreenElement\", \"fullscreenEnabled\", \"fullscreenchange\", \"fullscreenerror\"],\n    // New WebKit\n    [\"webkitRequestFullscreen\", \"webkitExitFullscreen\", \"webkitFullscreenElement\", \"webkitFullscreenEnabled\", \"webkitfullscreenchange\", \"webkitfullscreenerror\"],\n    // Old WebKit (Safari 5.1)\n    [\"webkitRequestFullScreen\", \"webkitCancelFullScreen\", \"webkitCurrentFullScreenElement\", \"webkitCancelFullScreen\", \"webkitfullscreenchange\", \"webkitfullscreenerror\"],\n    // Mozilla\n    [\"mozRequestFullScreen\", \"mozCancelFullScreen\", \"mozFullScreenElement\", \"mozFullScreenEnabled\", \"mozfullscreenchange\", \"mozfullscreenerror\"],\n    // MS\n    [\"msRequestFullscreen\", \"msExitFullscreen\", \"msFullscreenElement\", \"msFullscreenEnabled\", \"MSFullscreenChange\", \"MSFullscreenError\"]];\n    this.keyboardAllowed = typeof Element !== \"undefined\" && \"ALLOW_KEYBOARD_INPUT\" in Element;\n    /** @type {?} */\n    const ret = {};\n    /** @type {?} */\n    let val;\n    for (let i = 0; i < this.fnMap.length; i++) {\n      val = this.fnMap[i];\n      if (val && val[1] in document) {\n        for (i = 0; i < val.length; i++) {\n          // Map everything to the first list of keys\n          ret[this.fnMap[0][i].toString()] = val[i];\n        }\n        this.fn = ret;\n      }\n    }\n  }\n  /**\r\n   * @param {?} elem\r\n   * @return {?}\r\n   */\n  request(elem) {\n    /** @type {?} */\n    const request = this.fn.requestFullscreen;\n    elem = elem || document.documentElement;\n    // Work around Safari 5.1 bug: reports support for\n    // keyboard in fullscreen even though it doesn't.\n    // Browser sniffing, since the alternative with\n    // setTimeout is even worse.\n    if (/5\\.1[.\\d]* Safari/.test(navigator.userAgent)) {\n      elem[request]();\n    } else {\n      elem[request](this.keyboardAllowed ? /** @type {?} */Element.ALLOW_KEYBOARD_INPUT : {});\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  exit() {\n    document[this.fn.exitFullscreen]();\n  }\n  /**\r\n   * @param {?} elem\r\n   * @return {?}\r\n   */\n  toggle(elem) {\n    if (this.isFullscreen()) {\n      this.exit();\n    } else {\n      this.request(elem);\n    }\n  }\n  /**\r\n   * @param {?} callback\r\n   * @return {?}\r\n   */\n  onChange(callback) {\n    document.addEventListener(this.fn.fullscreenchange, callback, false);\n  }\n  /**\r\n   * @param {?} callback\r\n   * @return {?}\r\n   */\n  onError(callback) {\n    document.addEventListener(this.fn.fullscreenerror, callback, false);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  isFullscreen() {\n    return Boolean(document[this.fn.fullscreenElement]);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  isEnabled() {\n    // Coerce to boolean in case of old WebKit\n    return Boolean(document[this.fn.fullscreenEnabled]);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  getElement() {\n    return document[this.fn.fullscreenElement];\n  }\n}\nFullscreenService.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\nFullscreenService.ctorParameters = () => [];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatDownloadButtonComponent {\n  constructor() {}\n}\nMatDownloadButtonComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-download-button\",\n    template: \"<a mat-icon-button [href]=\\\"video?.currentSrc\\\" [download]=\\\"title\\\">\\r\\n  <mat-icon>file_download</mat-icon>\\r\\n</a>\\r\\n\",\n    styles: [\"a{color:inherit;text-decoration:none}\"]\n  }]\n}];\n/** @nocollapse */\nMatDownloadButtonComponent.ctorParameters = () => [];\nMatDownloadButtonComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  title: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatFrameByFrameControlComponent {\n  constructor() {\n    this.fps = 29.97;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnInit() {}\n  /**\r\n   * @param {?} nbFrames\r\n   * @return {?}\r\n   */\n  seekFrames(nbFrames) {\n    if (!this.video.paused) {\n      this.video.pause();\n    }\n    /** @type {?} */\n    const currentFrames = this.video.currentTime * this.fps;\n    /** @type {?} */\n    const newPos = (currentFrames + nbFrames) / this.fps + 0.00001;\n    this.video.currentTime = newPos;\n  }\n}\nMatFrameByFrameControlComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-frame-by-frame-control\",\n    template: \"<button mat-icon-button (click)=\\\"seekFrames(-5)\\\">\\r\\n  <mat-icon>skip_previous</mat-icon>\\r\\n</button>\\r\\n\\r\\n<button mat-icon-button (click)=\\\"seekFrames(-1)\\\">\\r\\n  <mat-icon>arrow_left</mat-icon>\\r\\n</button>\\r\\n\\r\\n<button mat-icon-button (click)=\\\"seekFrames(1)\\\">\\r\\n  <mat-icon>arrow_right</mat-icon>\\r\\n</button>\\r\\n\\r\\n<button mat-icon-button (click)=\\\"seekFrames(5)\\\">\\r\\n  <mat-icon>skip_next</mat-icon>\\r\\n</button>\\r\\n\",\n    styles: [\"\"]\n  }]\n}];\n/** @nocollapse */\nMatFrameByFrameControlComponent.ctorParameters = () => [];\nMatFrameByFrameControlComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  fps: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatFullscreenButtonComponent {\n  /**\r\n   * @param {?} fscreen\r\n   * @param {?} evt\r\n   */\n  constructor(fscreen, evt) {\n    this.fscreen = fscreen;\n    this.evt = evt;\n    this.canFullscreen = false;\n    this.fullscreen = false;\n    this.fullscreenChanged = new EventEmitter();\n    this.keyboard = true;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnInit() {\n    if (this.fscreen.isEnabled()) {\n      this.canFullscreen = true;\n    }\n    this.fscreen.onChange(\n    /**\r\n    * @param {?} event\r\n    * @return {?}\r\n    */\n    event => this.fscreen.isFullscreen() ? this.onChangesFullscreen(true) : this.onChangesFullscreen(false));\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  setFullscreen(value) {\n    if (this.canFullscreen && this.fullscreen !== value) {\n      this.toggleFullscreen();\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  toggleFullscreen() {\n    this.fullscreen = !this.fullscreen;\n    this.updateFullscreen();\n  }\n  /**\r\n   * @return {?}\r\n   */\n  updateFullscreen() {\n    this.fullscreen ? this.fscreen.request(this.player) : this.fscreen.exit();\n    this.fullscreenChanged.emit(this.fullscreen);\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  onChangesFullscreen(value) {\n    this.fullscreen = value;\n    this.fullscreenChanged.emit(this.fullscreen);\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  onFullscreenKey(event) {\n    if (this.keyboard) {\n      this.toggleFullscreen();\n      event.preventDefault();\n    }\n  }\n}\nMatFullscreenButtonComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-fullscreen-button\",\n    template: \"<button mat-icon-button [disabled]=\\\"!canFullscreen\\\" (click)=\\\"toggleFullscreen()\\\">\\r\\n  <mat-icon *ngIf=\\\"!fullscreen\\\">fullscreen</mat-icon>\\r\\n  <mat-icon *ngIf=\\\"fullscreen\\\">fullscreen_exit</mat-icon>\\r\\n</button>\\r\\n\",\n    styles: [\"\"]\n  }]\n}];\n/** @nocollapse */\nMatFullscreenButtonComponent.ctorParameters = () => [{\n  type: FullscreenService\n}, {\n  type: EventService\n}];\nMatFullscreenButtonComponent.propDecorators = {\n  player: [{\n    type: Input\n  }],\n  fullscreen: [{\n    type: Input\n  }],\n  fullscreenChanged: [{\n    type: Output\n  }],\n  keyboard: [{\n    type: Input\n  }],\n  onFullscreenKey: [{\n    type: HostListener,\n    args: [\"document:keyup.f\", [\"$event\"]]\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatPlayButtonComponent {\n  /**\r\n   * @param {?} renderer\r\n   * @param {?} evt\r\n   */\n  constructor(renderer, evt) {\n    this.renderer = renderer;\n    this.evt = evt;\n    this.play = false;\n    this.playChanged = new EventEmitter();\n    this.keyboard = true;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngAfterViewInit() {\n    this.events = [{\n      element: this.video,\n      name: \"play\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.setVideoPlayback(true),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"pause\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.setVideoPlayback(false),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"durationchange\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.setVideoPlayback(false),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"ended\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.setVideoPlayback(false),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"click\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.toggleVideoPlayback(),\n      dispose: null\n    }];\n    this.evt.addEvents(this.renderer, this.events);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnDestroy() {\n    this.evt.removeEvents(this.events);\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  setVideoPlayback(value) {\n    if (this.play !== value) {\n      this.toggleVideoPlayback();\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  toggleVideoPlayback() {\n    this.play = !this.play;\n    this.updateVideoPlayback();\n  }\n  /**\r\n   * @return {?}\r\n   */\n  updateVideoPlayback() {\n    this.play ? this.video.play() : this.video.pause();\n    this.playChanged.emit(this.play);\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  onPlayKey(event) {\n    if (this.keyboard) {\n      this.toggleVideoPlayback();\n      event.preventDefault();\n    }\n  }\n}\nMatPlayButtonComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-play-button\",\n    template: \"<button mat-icon-button (click)=\\\"toggleVideoPlayback()\\\">\\r\\n  <mat-icon *ngIf=\\\"!play\\\">play_arrow</mat-icon>\\r\\n  <mat-icon *ngIf=\\\"play\\\">pause</mat-icon>\\r\\n</button>\\r\\n\",\n    styles: [\"\"]\n  }]\n}];\n/** @nocollapse */\nMatPlayButtonComponent.ctorParameters = () => [{\n  type: Renderer2\n}, {\n  type: EventService\n}];\nMatPlayButtonComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  play: [{\n    type: Input\n  }],\n  playChanged: [{\n    type: Output\n  }],\n  keyboard: [{\n    type: Input\n  }],\n  onPlayKey: [{\n    type: HostListener,\n    args: [\"document:keyup.space\", [\"$event\"]]\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatQualityControlComponent {\n  constructor() {}\n}\nMatQualityControlComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-quality-control\",\n    template: \"<div *ngIf=\\\"video && video.videoHeight\\\" class=\\\"quality\\\">{{ video.videoHeight }}p</div>\\r\\n\",\n    styles: [\".quality{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}\"]\n  }]\n}];\n/** @nocollapse */\nMatQualityControlComponent.ctorParameters = () => [];\nMatQualityControlComponent.propDecorators = {\n  video: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatSeekProgressControlComponent {\n  /**\r\n   * @param {?} renderer\r\n   * @param {?} evt\r\n   */\n  constructor(renderer, evt) {\n    this.renderer = renderer;\n    this.evt = evt;\n    this.curTimePercent = 0;\n    this.bufTimePercent = 0;\n    this.video = null;\n    this.color = \"primary\";\n    this.currentTime = 0;\n    this.currentTimeChanged = new EventEmitter();\n    this.bufferedTime = 0;\n    this.bufferedTimeChanged = new EventEmitter();\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngAfterViewInit() {\n    this.events = [{\n      element: this.video,\n      name: \"seeking\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.updateCurrentTime(this.video.currentTime),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"canplaythrough\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.updateBufferedTime(),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"timeupdate\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.updateCurrentTime(this.video.currentTime),\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"progress\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.updateBufferedTime(),\n      dispose: null\n    }];\n    this.evt.addEvents(this.renderer, this.events);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnDestroy() {\n    this.evt.removeEvents(this.events);\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  seekVideo(value) {\n    /** @type {?} */\n    const percentage = value / 100;\n    /** @type {?} */\n    const newTime = this.video.duration * percentage;\n    this.video.currentTime = newTime;\n  }\n  /**\r\n   * @param {?} time\r\n   * @return {?}\r\n   */\n  updateCurrentTime(time) {\n    this.currentTime = time;\n    this.curTimePercent = this.updateTime(this.currentTimeChanged, this.currentTime);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  updateBufferedTime() {\n    if (this.video.buffered.length > 0) {\n      /** @type {?} */\n      let largestBufferValue = 0;\n      for (let i = 0; i < this.video.buffered.length; i++) {\n        /** @type {?} */\n        const cur = this.video.currentTime;\n        /** @type {?} */\n        const start = this.video.buffered.start(i);\n        /** @type {?} */\n        const end = this.video.buffered.end(i);\n        if (start <= cur && end > cur && end - start > largestBufferValue) {\n          largestBufferValue = end;\n        }\n      }\n      this.bufferedTime = largestBufferValue;\n      this.bufTimePercent = this.updateTime(this.bufferedTimeChanged, this.bufferedTime);\n    }\n  }\n  /**\r\n   * @param {?} emitter\r\n   * @param {?} time\r\n   * @return {?}\r\n   */\n  updateTime(emitter, time) {\n    emitter.emit(time);\n    return time / this.video.duration * 100;\n  }\n}\nMatSeekProgressControlComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-seek-progress-control\",\n    template: \"<mat-slider-progress-bar\\r\\n  [color]=\\\"color\\\"\\r\\n  mode=\\\"buffer\\\"\\r\\n  step=\\\"0.01\\\"\\r\\n  [value]=\\\"curTimePercent\\\"\\r\\n  [bufferValue]=\\\"bufTimePercent\\\"\\r\\n  (input)=\\\"seekVideo($event.value)\\\"\\r\\n></mat-slider-progress-bar>\\r\\n\",\n    styles: [\"\"]\n  }]\n}];\n/** @nocollapse */\nMatSeekProgressControlComponent.ctorParameters = () => [{\n  type: Renderer2\n}, {\n  type: EventService\n}];\nMatSeekProgressControlComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  color: [{\n    type: Input\n  }],\n  currentTime: [{\n    type: Input\n  }],\n  currentTimeChanged: [{\n    type: Output\n  }],\n  bufferedTime: [{\n    type: Input\n  }],\n  bufferedTimeChanged: [{\n    type: Output\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatTimeControlComponent {\n  constructor() {}\n}\nMatTimeControlComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-time-control\",\n    template: \"<div class=\\\"playtime\\\">{{ video?.currentTime | secondsToTime }} / {{ video?.duration | secondsToTime }}</div>\\r\\n\",\n    styles: [\".playtime{display:inline;font-size:12px}\"]\n  }]\n}];\n/** @nocollapse */\nMatTimeControlComponent.ctorParameters = () => [];\nMatTimeControlComponent.propDecorators = {\n  video: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVideoSpinnerComponent {\n  /**\r\n   * @param {?} renderer\r\n   * @param {?} evt\r\n   */\n  constructor(renderer, evt) {\n    this.renderer = renderer;\n    this.evt = evt;\n    this.spinner = \"spin\";\n    this.videoBuffering = false;\n    this.events = [];\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngAfterViewInit() {\n    this.events = [{\n      element: this.video,\n      name: \"loadstart\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoBuffering = true,\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"loadedmetadata\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoBuffering = false,\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"playing\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoBuffering = false,\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"waiting\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoBuffering = true,\n      dispose: null\n    }, {\n      element: this.video,\n      name: \"durationchange\",\n      callback:\n      /**\r\n      * @param {?} event\r\n      * @return {?}\r\n      */\n      event => this.videoBuffering = true,\n      dispose: null\n    }];\n    this.video.onloadeddata =\n    /**\r\n    * @return {?}\r\n    */\n    () => this.videoBuffering = false;\n    this.evt.addEvents(this.renderer, this.events);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngOnDestroy() {\n    this.video.onloadeddata = null;\n    this.evt.removeEvents(this.events);\n  }\n}\nMatVideoSpinnerComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-video-spinner\",\n    template: \"<div *ngIf=\\\"videoBuffering\\\" [class]=\\\"spinner\\\"></div>\\n\",\n    styles: [\":host{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}\", \".spin{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}\", \".dot{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{transform:scale(0)}100%{transform:scale(1);opacity:0}}\", \".split-ring{display:inline-block;width:64px;height:64px}.split-ring:after{content:\\\" \\\";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}\", \".hourglass{display:inline-block;position:relative;width:64px;height:64px}.hourglass:after{content:\\\" \\\";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{transform:rotate(720deg)}}\"]\n  }]\n}];\n/** @nocollapse */\nMatVideoSpinnerComponent.ctorParameters = () => [{\n  type: Renderer2\n}, {\n  type: EventService\n}];\nMatVideoSpinnerComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  spinner: [{\n    type: Input\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVolumeControlComponent {\n  /**\r\n   * @param {?} evt\r\n   */\n  constructor(evt) {\n    this.evt = evt;\n    this.video = null;\n    this.color = \"primary\";\n    this.volume = 1;\n    this.volumeChanged = new EventEmitter();\n    this.muted = false;\n    this.mutedChanged = new EventEmitter();\n    this.keyboard = true;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  ngAfterViewInit() {\n    this.updateMuted(false);\n  }\n  /**\r\n   * @param {?} changes\r\n   * @return {?}\r\n   */\n  ngOnChanges(changes) {\n    if (changes.muted) {\n      this.updateMuted(false);\n    }\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  setVolume(value) {\n    this.volume = value;\n    this.video.volume = this.volume;\n    this.volumeChanged.emit(this.volume);\n    if (this.volume > 0) {\n      this.setMuted(false);\n    }\n  }\n  /**\r\n   * @param {?} value\r\n   * @return {?}\r\n   */\n  setMuted(value) {\n    if (this.muted !== value) {\n      this.toggleMuted();\n    }\n  }\n  /**\r\n   * @return {?}\r\n   */\n  toggleMuted() {\n    this.muted = !this.muted;\n    this.updateMuted();\n  }\n  /**\r\n   * @param {?=} emitChange\r\n   * @return {?}\r\n   */\n  updateMuted(emitChange = true) {\n    if (this.video) {\n      this.video.muted = this.muted;\n    }\n    if (emitChange) {\n      this.mutedChanged.emit(this.muted);\n    }\n  }\n  /**\r\n   * @param {?} event\r\n   * @return {?}\r\n   */\n  onMuteKey(event) {\n    if (this.keyboard) {\n      this.toggleMuted();\n      event.preventDefault();\n    }\n  }\n}\nMatVolumeControlComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: \"mat-volume-control\",\n    template: \"<div class=\\\"volume-control\\\">\\r\\n  <button mat-icon-button (click)=\\\"toggleMuted()\\\">\\r\\n    <mat-icon *ngIf=\\\"muted || volume === 0\\\">volume_off</mat-icon>\\r\\n    <mat-icon *ngIf=\\\"!muted && volume > 0 && volume < 0.25\\\">volume_mute</mat-icon>\\r\\n    <mat-icon *ngIf=\\\"!muted && volume >= 0.25 && volume < 0.5\\\">volume_down</mat-icon>\\r\\n    <mat-icon *ngIf=\\\"!muted && volume >= 0.5\\\">volume_up</mat-icon>\\r\\n  </button>\\r\\n  <mat-slider class=\\\"volume-slider\\\" [color]=\\\"color\\\" min=\\\"0\\\" max=\\\"1\\\" step=\\\"0.01\\\" value=\\\"1\\\" (input)=\\\"setVolume($event.value)\\\"> </mat-slider>\\r\\n</div>\\r\\n\",\n    styles: [\".volume-control{display:inline}.volume-slider{margin-left:-15px}::ng-deep.mat-slider-thumb{border-color:transparent!important}::ng-deep.mat-slider-track-background{background-color:#d3d3d3!important;transform:translateX(0)!important}.volume-control .volume-slider{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control:hover .volume-slider{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}\"]\n  }]\n}];\n/** @nocollapse */\nMatVolumeControlComponent.ctorParameters = () => [{\n  type: EventService\n}];\nMatVolumeControlComponent.propDecorators = {\n  video: [{\n    type: Input\n  }],\n  color: [{\n    type: Input\n  }],\n  volume: [{\n    type: Input\n  }],\n  volumeChanged: [{\n    type: Output\n  }],\n  muted: [{\n    type: Input\n  }],\n  mutedChanged: [{\n    type: Output\n  }],\n  keyboard: [{\n    type: Input\n  }],\n  onMuteKey: [{\n    type: HostListener,\n    args: [\"document:keyup.m\", [\"$event\"]]\n  }]\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass MatVideoModule {}\nMatVideoModule.decorators = [{\n  type: NgModule,\n  args: [{\n    declarations: [SecondsToTimePipe, MatVideoComponent, MatSliderProgressBarComponent, MatPlayButtonComponent, MatVolumeControlComponent, MatDownloadButtonComponent, MatFullscreenButtonComponent, MatTimeControlComponent, MatQualityControlComponent, MatVideoSpinnerComponent, MatSeekProgressControlComponent, MatVideoSourceDirective, MatVideoTrackDirective, MatFrameByFrameControlComponent],\n    imports: [CommonModule, MatIconModule, MatButtonModule, MatSliderModule],\n    exports: [MatVideoComponent, MatVideoSourceDirective, MatVideoTrackDirective],\n    providers: [FullscreenService, EventService]\n  }]\n}];\nexport { MatVideoModule, SecondsToTimePipe as ɵa, MatVideoComponent as ɵb, EventService as ɵc, MatSliderProgressBarComponent as ɵd, MatPlayButtonComponent as ɵe, MatVolumeControlComponent as ɵf, MatDownloadButtonComponent as ɵg, MatFullscreenButtonComponent as ɵh, FullscreenService as ɵi, MatTimeControlComponent as ɵj, MatQualityControlComponent as ɵk, MatVideoSpinnerComponent as ɵl, MatSeekProgressControlComponent as ɵm, MatVideoSourceDirective as ɵn, MatVideoTrackDirective as ɵo, MatFrameByFrameControlComponent as ɵp };\n//# sourceMappingURL=mat-video.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}