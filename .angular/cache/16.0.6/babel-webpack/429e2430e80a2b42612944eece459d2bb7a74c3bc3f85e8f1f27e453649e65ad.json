{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./trabajos.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./trabajos.component.css?ngResource\";\nimport { Component, ViewChild } from '@angular/core';\nlet TrabajosComponent = class TrabajosComponent {\n  constructor() {\n    this.scrollAmount = 0;\n    this.speed = 0.5;\n    this.isHovered = false;\n    this.isPaused = false;\n    this.isInitialized = false;\n    // Variables para drag functionality\n    this.isDragging = false;\n    this.startX = 0;\n    this.startScrollAmount = 0;\n    this.dragVelocity = 0;\n    this.lastDragTime = 0;\n    this.lastDragX = 0;\n    this.isMobile = false;\n    // Variables para modal\n    this.selectedImage = null;\n    this.showModal = false;\n    this.scrollPosition = 0;\n    this.trabajos = [{\n      img: \"assets/img/IMG-20250726-WA0053.jpg\",\n      titulo: \"Roller Screen en Ventanal\",\n      descripcion: \"Cortina roller screen en un amplio ventanal, permitiendo la visibilidad exterior con filtro UV.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0056.jpg\",\n      titulo: \"Tradicional en pinza italiana con blackout\",\n      descripcion: \"Cortina tradicional en pinza italiana con blackout.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/roller-translucida.jpeg\",\n      titulo: \"Tela Screen\",\n      descripcion: \"Filtra el sol directo, protegiendo tus espacios del deterioro.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250721-WA0006.jpg\",\n      titulo: \"Pinza italiana\",\n      descripcion: \"Pinza italiana en tela Lino.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/cortina-tipo-antigua-translucida.jpeg\",\n      titulo: \"Pinza italiana\",\n      descripcion: \"Pinza italiana en tela Voile.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0061.jpg\",\n      titulo: \"En Voile\",\n      descripcion: \"Cortinas en voile.\",\n      size: \"giant\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0059.jpg\",\n      titulo: \"Cortina Texturizada\",\n      descripcion: \"Cortina con textura sutil, combinando funcionalidad y estilo.\",\n      size: \"normal\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0057.jpg\",\n      titulo: \"Tradicional en Blackout\",\n      descripcion: \"Cortina tradicional en blackout, brindando privacidad sin obstaculizar el espacio.\",\n      size: \"normal\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0052.jpg\",\n      titulo: \"Roller Blackout Beige\",\n      descripcion: \"Cortina roller blackout de color beige.\",\n      size: \"giant\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0050.jpg\",\n      titulo: \"Screen 5%\",\n      descripcion: \"Tela Screen 5%.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0060.jpg\",\n      titulo: \"Cortina Clásica\",\n      descripcion: \"Un toque de elegancia y privacidad para tu espacio.\",\n      size: \"normal\"\n    }, {\n      img: \"assets/img/roller-blackout.jpeg\",\n      titulo: \"Black Out\",\n      descripcion: \"Aislante térmico y sonoro. Totalmente opaca.\",\n      size: \"normal\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0055.jpg\",\n      titulo: \"Cortinas Screen\",\n      descripcion: \"Cortinas que garantizan privacidad y control total de la luz.\",\n      size: \"wide\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0062.jpg\",\n      titulo: \"Cortina tradicional en Voile\",\n      descripcion: \"Dormitorio con cortina roller que permite regular la entrada de luz y asegurar el descanso.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0058.jpg\",\n      titulo: \"Cortinas en Sala de Estar\",\n      descripcion: \"Cortinas que complementan la decoración de una sala de estar, aportando calidez.\",\n      size: \"wide\"\n    }, {\n      img: \"assets/img/roller-rayada.jpeg\",\n      titulo: \"Bambú\",\n      descripcion: \"Ideal para ambientes con estilo natural.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/IMG-20250726-WA0051.jpg\",\n      titulo: \"Cortina Roller\",\n      descripcion: \"Tela Screen 5%.\",\n      size: \"large\"\n    }, {\n      img: \"assets/img/cortina-tipo-antigua.jpeg\",\n      titulo: \"Tradicional\",\n      descripcion: \"Cortina tradicional doble en Pinza Americana.\",\n      size: \"giant\"\n    }];\n  }\n  get trabajosInfinitos() {\n    return [...this.trabajos, ...this.trabajos, ...this.trabajos];\n  }\n  ngAfterViewInit() {\n    this.checkIfMobile();\n    setTimeout(() => {\n      this.setupEventListeners();\n      this.startScrollAnimation();\n    }, 300);\n    setTimeout(() => {\n      if (!this.isInitialized) {\n        this.startScrollAnimation();\n      }\n    }, 1000);\n    // Listener para cambios de tamaño de ventana\n    window.addEventListener('resize', () => {\n      this.checkIfMobile();\n    });\n  }\n  ngOnDestroy() {\n    this.cleanup();\n    if (this.momentumId) {\n      cancelAnimationFrame(this.momentumId);\n    }\n  }\n  checkIfMobile() {\n    this.isMobile = window.innerWidth <= 768;\n  }\n  cleanup() {\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = undefined;\n    }\n  }\n  setupEventListeners() {\n    const container = this.sliderContainer.nativeElement;\n    // Eventos de mouse para desktop\n    if (!this.isMobile) {\n      container.addEventListener('mouseenter', () => {\n        this.isHovered = true;\n      });\n      container.addEventListener('mouseleave', () => {\n        this.isHovered = false;\n      });\n      this.setupMouseEvents(container);\n    } else {\n      // Eventos touch para móvil\n      this.setupTouchEvents(container);\n    }\n    // Manejar visibilidad de la pestaña\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.isPaused = true;\n      } else {\n        this.isPaused = false;\n      }\n    });\n  }\n  setupMouseEvents(container) {\n    let mouseStartTime = 0;\n    let mouseStartX = 0;\n    let hasMoved = false;\n    let isMouseDown = false;\n    // Mouse down\n    container.addEventListener('mousedown', e => {\n      // Solo botón izquierdo\n      if (e.button !== 0) return;\n      mouseStartTime = Date.now();\n      mouseStartX = e.clientX;\n      hasMoved = false;\n      isMouseDown = true;\n      this.startX = e.clientX;\n      this.startScrollAmount = this.scrollAmount;\n      this.isDragging = true;\n      this.isPaused = true;\n      this.dragVelocity = 0;\n      this.lastDragTime = Date.now();\n      this.lastDragX = this.startX;\n      if (this.momentumId) {\n        cancelAnimationFrame(this.momentumId);\n        this.momentumId = undefined;\n      }\n      container.style.cursor = 'grabbing';\n      // Prevenir selección de texto\n      e.preventDefault();\n    });\n    // Mouse move\n    container.addEventListener('mousemove', e => {\n      if (!this.isDragging || !isMouseDown) return;\n      e.preventDefault();\n      hasMoved = true;\n      const currentX = e.clientX;\n      const deltaX = this.startX - currentX;\n      const currentTime = Date.now();\n      // Calcular velocidad para momentum\n      if (currentTime - this.lastDragTime > 0) {\n        this.dragVelocity = (this.lastDragX - currentX) / (currentTime - this.lastDragTime);\n      }\n      this.lastDragX = currentX;\n      this.lastDragTime = currentTime;\n      // Actualizar posición\n      const newScrollAmount = this.startScrollAmount + deltaX;\n      const singleSetWidth = this.calculateSingleSetWidth();\n      // Wrap around logic\n      if (newScrollAmount < 0) {\n        this.scrollAmount = singleSetWidth + newScrollAmount % singleSetWidth;\n      } else if (newScrollAmount >= singleSetWidth) {\n        this.scrollAmount = newScrollAmount % singleSetWidth;\n      } else {\n        this.scrollAmount = newScrollAmount;\n      }\n      this.updateSliderPosition();\n    });\n    // Mouse up\n    container.addEventListener('mouseup', e => {\n      if (!isMouseDown) return;\n      const mouseEndTime = Date.now();\n      const mouseDuration = mouseEndTime - mouseStartTime;\n      const mouseDistance = Math.abs(e.clientX - mouseStartX);\n      // Si fue un click rápido sin mucho movimiento = CLICK\n      if (mouseDuration < 300 && mouseDistance < 10 && !hasMoved) {\n        const target = e.target;\n        let imageElement = null;\n        // Buscar imagen\n        if (target.tagName === 'IMG') {\n          imageElement = target;\n        } else {\n          const parentLi = target.closest('li');\n          if (parentLi) {\n            imageElement = parentLi.querySelector('img');\n          }\n        }\n        if (imageElement) {\n          const imgSrc = imageElement.src;\n          const trabajo = this.trabajos.find(t => {\n            const imgName = t.img.split('/').pop();\n            return imgSrc.includes(imgName || '') || imgSrc.includes(t.img);\n          });\n          if (trabajo) {\n            this.openModal(trabajo);\n            // Reset estados y salir\n            this.resetMouseStates(container);\n            isMouseDown = false;\n            return;\n          }\n        }\n      }\n      this.resetMouseStates(container);\n      isMouseDown = false;\n      // Aplicar momentum si hay velocidad\n      if (Math.abs(this.dragVelocity) > 0.1 && hasMoved) {\n        this.applyMomentum();\n      } else {\n        this.isPaused = false;\n      }\n    });\n    // Mouse leave - para cuando el mouse sale del container\n    container.addEventListener('mouseleave', () => {\n      if (this.isDragging && isMouseDown) {\n        this.resetMouseStates(container);\n        isMouseDown = false;\n        // Aplicar momentum si hay velocidad\n        if (Math.abs(this.dragVelocity) > 0.1 && hasMoved) {\n          this.applyMomentum();\n        } else {\n          this.isPaused = false;\n        }\n      }\n    });\n    // Mouse up global - por si sueltan fuera del container\n    document.addEventListener('mouseup', () => {\n      if (isMouseDown) {\n        this.resetMouseStates(container);\n        isMouseDown = false;\n        this.isPaused = false;\n      }\n    });\n  }\n  setupTouchEvents(container) {\n    let touchStartTime = 0;\n    let touchStartX = 0;\n    let touchStartY = 0;\n    let hasMoved = false;\n    let holdTimer;\n    let isHolding = false;\n    // Touch start\n    container.addEventListener('touchstart', e => {\n      if (e.touches.length !== 1) return;\n      touchStartTime = Date.now();\n      touchStartX = e.touches[0].clientX;\n      touchStartY = e.touches[0].clientY;\n      hasMoved = false;\n      isHolding = false;\n      this.startX = e.touches[0].clientX;\n      this.startScrollAmount = this.scrollAmount;\n      this.dragVelocity = 0;\n      this.lastDragTime = Date.now();\n      this.lastDragX = this.startX;\n      if (this.momentumId) {\n        cancelAnimationFrame(this.momentumId);\n        this.momentumId = undefined;\n      }\n      // Timer para detectar \"hold\" (200ms)\n      holdTimer = setTimeout(() => {\n        isHolding = true;\n        this.isDragging = true;\n        this.isPaused = true;\n        container.style.cursor = 'grabbing';\n        // Vibración sutil para feedback (si está disponible)\n        if ('vibrate' in navigator) {\n          navigator.vibrate(50);\n        }\n      }, 200);\n    }, {\n      passive: false\n    });\n    // Touch move\n    container.addEventListener('touchmove', e => {\n      if (e.touches.length !== 1) return;\n      const currentX = e.touches[0].clientX;\n      const currentY = e.touches[0].clientY;\n      const deltaX = Math.abs(currentX - touchStartX);\n      const deltaY = Math.abs(currentY - touchStartY);\n      // Si se mueve más de 10px, cancelar el timer de hold\n      if ((deltaX > 10 || deltaY > 10) && !isHolding) {\n        clearTimeout(holdTimer);\n        hasMoved = true;\n      }\n      // Solo procesar drag si ya estamos en modo holding\n      if (!this.isDragging || !isHolding) return;\n      e.preventDefault();\n      hasMoved = true;\n      const deltaXScroll = this.startX - currentX;\n      const currentTime = Date.now();\n      // Calcular velocidad para momentum\n      if (currentTime - this.lastDragTime > 0) {\n        this.dragVelocity = (this.lastDragX - currentX) / (currentTime - this.lastDragTime);\n      }\n      this.lastDragX = currentX;\n      this.lastDragTime = currentTime;\n      // Actualizar posición\n      const newScrollAmount = this.startScrollAmount + deltaXScroll;\n      const singleSetWidth = this.calculateSingleSetWidth();\n      // Wrap around logic\n      if (newScrollAmount < 0) {\n        this.scrollAmount = singleSetWidth + newScrollAmount % singleSetWidth;\n      } else if (newScrollAmount >= singleSetWidth) {\n        this.scrollAmount = newScrollAmount % singleSetWidth;\n      } else {\n        this.scrollAmount = newScrollAmount;\n      }\n      this.updateSliderPosition();\n    }, {\n      passive: false\n    });\n    // Touch end\n    container.addEventListener('touchend', e => {\n      clearTimeout(holdTimer);\n      const touchEndTime = Date.now();\n      const touchDuration = touchEndTime - touchStartTime;\n      const touchDistance = Math.abs(e.changedTouches[0].clientX - touchStartX);\n      // Si fue un tap rápido, sin hold y sin mucho movimiento = CLICK\n      if (touchDuration < 200 && touchDistance < 10 && !hasMoved && !isHolding) {\n        // Buscar el elemento imagen más cercano\n        const target = e.target;\n        let imageElement = null;\n        let trabajo = null;\n        // Buscar la imagen de diferentes maneras\n        if (target.tagName === 'IMG') {\n          imageElement = target;\n        } else {\n          imageElement = target.closest('li')?.querySelector('img');\n        }\n        if (imageElement) {\n          const imgSrc = imageElement.src;\n          // Buscar el trabajo correspondiente\n          trabajo = this.trabajos.find(t => {\n            const imgName = t.img.split('/').pop();\n            return imgSrc.includes(imgName || '');\n          }) || this.trabajos.find(t => imgSrc.includes(t.img));\n          if (trabajo) {\n            this.openModal(trabajo);\n            return; // Salir para evitar aplicar momentum\n          }\n        }\n      }\n      // Reset estados\n      this.isDragging = false;\n      isHolding = false;\n      container.style.cursor = 'grab';\n      // Aplicar momentum solo si se hizo drag y hay velocidad\n      if (Math.abs(this.dragVelocity) > 0.1 && hasMoved && isHolding) {\n        this.applyMomentum();\n      } else {\n        this.isPaused = false;\n      }\n    });\n    // Touch cancel - por si se interrumpe el touch\n    container.addEventListener('touchcancel', () => {\n      clearTimeout(holdTimer);\n      this.isDragging = false;\n      isHolding = false;\n      this.isPaused = false;\n      container.style.cursor = 'grab';\n    });\n  }\n  resetMouseStates(container) {\n    this.isDragging = false;\n    container.style.cursor = 'grab';\n  }\n  applyMomentum() {\n    const friction = 0.95;\n    const minVelocity = 0.1;\n    const momentum = () => {\n      if (Math.abs(this.dragVelocity) < minVelocity) {\n        this.isPaused = false;\n        return;\n      }\n      this.scrollAmount += this.dragVelocity * 5;\n      this.dragVelocity *= friction;\n      const singleSetWidth = this.calculateSingleSetWidth();\n      if (this.scrollAmount < 0) {\n        this.scrollAmount = singleSetWidth + this.scrollAmount % singleSetWidth;\n      } else if (this.scrollAmount >= singleSetWidth) {\n        this.scrollAmount = this.scrollAmount % singleSetWidth;\n      }\n      this.updateSliderPosition();\n      this.momentumId = requestAnimationFrame(momentum);\n    };\n    this.momentumId = requestAnimationFrame(momentum);\n  }\n  updateSliderPosition() {\n    const sliderGrid = this.sliderGrid.nativeElement;\n    sliderGrid.style.transform = `translateX(-${this.scrollAmount}px)`;\n  }\n  startScrollAnimation() {\n    if (this.isInitialized) return;\n    const sliderGrid = this.sliderGrid.nativeElement;\n    this.isInitialized = true;\n    const animate = () => {\n      if (!this.isHovered && !this.isPaused && !document.hidden && !this.isDragging) {\n        this.scrollAmount += this.speed;\n        const singleSetWidth = this.calculateSingleSetWidth();\n        if (this.scrollAmount >= singleSetWidth) {\n          this.scrollAmount = 0;\n        }\n        sliderGrid.style.transform = `translateX(-${this.scrollAmount}px)`;\n      }\n      this.animationId = requestAnimationFrame(animate);\n    };\n    setTimeout(() => {\n      animate();\n    }, 200);\n  }\n  calculateSingleSetWidth() {\n    const sliderGrid = this.sliderGrid.nativeElement;\n    const items = sliderGrid.querySelectorAll('li');\n    const itemsPerSet = this.trabajos.length;\n    if (items.length === 0) return 2000;\n    const firstSetItems = Array.from(items).slice(0, itemsPerSet);\n    if (firstSetItems.length === 0) return 2000;\n    let maxRight = 0;\n    firstSetItems.forEach(item => {\n      const rect = item.getBoundingClientRect();\n      const containerRect = sliderGrid.getBoundingClientRect();\n      const relativeRight = rect.right - containerRect.left + 15;\n      maxRight = Math.max(maxRight, relativeRight);\n    });\n    if (maxRight === 0) {\n      const estimatedWidth = itemsPerSet * (280 + 15);\n      return estimatedWidth;\n    }\n    return maxRight;\n  }\n  getItemClass(index, size) {\n    const baseClass = 'item';\n    switch (size) {\n      case 'large':\n        return `${baseClass} item-large`;\n      case 'giant':\n        return `${baseClass} item-giant`;\n      case 'wide':\n        return `${baseClass} item-wide`;\n      default:\n        return `${baseClass} item-normal`;\n    }\n  }\n  // Métodos para modal\n  openModal(trabajo) {\n    this.selectedImage = trabajo;\n    this.showModal = true;\n    this.scrollPosition = window.pageYOffset;\n    // Bloquear scroll en toda la página\n    document.documentElement.style.overflow = 'hidden';\n  }\n  closeModal() {\n    this.showModal = false;\n    this.selectedImage = null;\n    // Desbloquear scroll\n    document.documentElement.style.overflow = '';\n    // Restaurar posición\n    window.scrollTo(0, this.scrollPosition);\n  }\n  onModalBackgroundClick(event) {\n    // Solo cerrar si se hace click en el background, no en la imagen o contenido\n    if (event.target === event.currentTarget) {\n      this.closeModal();\n      event.preventDefault();\n    }\n  }\n  // Métodos públicos para control manual\n  pauseScroll() {\n    this.isPaused = true;\n  }\n  resumeScroll() {\n    this.isPaused = false;\n  }\n  setSpeed(newSpeed) {\n    this.speed = Math.max(0.5, Math.min(3, newSpeed));\n  }\n  reinitializeSlider() {\n    this.cleanup();\n    this.isInitialized = false;\n    this.scrollAmount = 0;\n    setTimeout(() => {\n      this.startScrollAnimation();\n    }, 100);\n  }\n  static {\n    this.propDecorators = {\n      sliderContainer: [{\n        type: ViewChild,\n        args: ['sliderContainer']\n      }],\n      sliderGrid: [{\n        type: ViewChild,\n        args: ['sliderGrid']\n      }]\n    };\n  }\n};\nTrabajosComponent = __decorate([Component({\n  selector: 'app-trabajos',\n  template: __NG_CLI_RESOURCE__0,\n  styles: [__NG_CLI_RESOURCE__1]\n})], TrabajosComponent);\nexport { TrabajosComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}