{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"./header.component.html?ngResource\";\nimport __NG_CLI_RESOURCE__1 from \"./header.component.css?ngResource\";\nimport { Component, HostListener, NgZone } from '@angular/core';\nlet HeaderComponent = class HeaderComponent {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.menuAbierto = false;\n    this.previousScrollPosition = window.pageYOffset;\n    this.headerVisible = true;\n    this.isNavigating = false;\n  }\n  toggleMenu(event) {\n    if (event) {\n      event.stopPropagation();\n    }\n    this.menuAbierto = !this.menuAbierto;\n    // Gestión del scroll del body\n    if (this.menuAbierto) {\n      document.body.style.overflow = 'hidden';\n      document.documentElement.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n      document.documentElement.style.overflow = '';\n    }\n  }\n  hideBurguer() {\n    if (!this.menuAbierto) return; // Evitar ejecutar si ya está cerrado\n    this.menuAbierto = false;\n    document.body.style.overflow = '';\n    document.documentElement.style.overflow = '';\n  }\n  navigateToSection(event, sectionId) {\n    event.preventDefault();\n    event.stopPropagation();\n    console.log(`Navegando a: ${sectionId}`); // Debug log\n    // Verificar si el elemento existe\n    const targetElement = document.getElementById(sectionId);\n    if (!targetElement) {\n      console.error(`Elemento con ID '${sectionId}' no encontrado`);\n      return;\n    }\n    // Marcar navegación y forzar header visible\n    this.isNavigating = true;\n    this.headerVisible = true;\n    // Cerrar menú INMEDIATAMENTE\n    this.hideBurguer();\n    // Usar NgZone para asegurar detección de cambios\n    this.ngZone.run(() => {\n      // Pequeño delay para permitir que se cierre el menú\n      setTimeout(() => {\n        const headerHeight = 80; // Ajusta según necesites\n        const elementPosition = targetElement.getBoundingClientRect().top;\n        const offsetPosition = elementPosition + window.pageYOffset - headerHeight;\n        // Scroll suave\n        window.scrollTo({\n          top: Math.max(0, offsetPosition),\n          behavior: 'smooth'\n        });\n        console.log(`Scrolling a posición: ${offsetPosition}`); // Debug log\n        // Liberar bandera después del scroll\n        setTimeout(() => {\n          this.isNavigating = false;\n        }, 1500);\n      }, 150); // Timing optimizado\n    });\n  }\n\n  onWindowScroll() {\n    // No ocultar header si estamos navegando o el menú está abierto\n    if (this.isNavigating || this.menuAbierto) {\n      return;\n    }\n    const currentScroll = window.pageYOffset;\n    const scrollThreshold = 100;\n    const scrollDifference = Math.abs(currentScroll - this.previousScrollPosition);\n    // Solo actuar si hay un scroll significativo (evita micro-scrolls)\n    if (scrollDifference < 5) {\n      return;\n    }\n    // Lógica mejorada para mostrar/ocultar header\n    if (currentScroll > this.previousScrollPosition && currentScroll > scrollThreshold) {\n      // Scrolling hacia abajo\n      this.headerVisible = false;\n    } else if (currentScroll < this.previousScrollPosition || currentScroll <= scrollThreshold) {\n      // Scrolling hacia arriba o cerca del top\n      this.headerVisible = true;\n    }\n    this.previousScrollPosition = currentScroll;\n  }\n  onWindowResize() {\n    // Cerrar menú en resize para evitar problemas responsive\n    if (this.menuAbierto) {\n      this.hideBurguer();\n    }\n  }\n  onKeyDown(event) {\n    // Cerrar menú con ESC\n    if (event.key === 'Escape' && this.menuAbierto) {\n      this.hideBurguer();\n    }\n  }\n  onDocumentClick(event) {\n    if (!this.menuAbierto) return;\n    const target = event.target;\n    const hamburgerBtn = document.querySelector('.hamburger-btn');\n    const navContainer = document.querySelector('.nav-container');\n    // Cerrar solo si el click fue completamente fuera del menú\n    if (hamburgerBtn && !hamburgerBtn.contains(target) && navContainer && !navContainer.contains(target)) {\n      this.hideBurguer();\n    }\n  }\n  ngOnDestroy() {\n    // Limpiar estilos al destruir componente\n    document.body.style.overflow = '';\n    document.documentElement.style.overflow = '';\n    if (this.scrollTimeout) {\n      clearTimeout(this.scrollTimeout);\n    }\n  }\n  static {\n    this.ctorParameters = () => [{\n      type: NgZone\n    }];\n  }\n  static {\n    this.propDecorators = {\n      onWindowScroll: [{\n        type: HostListener,\n        args: ['window:scroll', []]\n      }],\n      onWindowResize: [{\n        type: HostListener,\n        args: ['window:resize', []]\n      }],\n      onKeyDown: [{\n        type: HostListener,\n        args: ['document:keydown', ['$event']]\n      }],\n      onDocumentClick: [{\n        type: HostListener,\n        args: ['document:click', ['$event']]\n      }]\n    };\n  }\n};\nHeaderComponent = __decorate([Component({\n  selector: 'app-header',\n  template: __NG_CLI_RESOURCE__0,\n  styles: [__NG_CLI_RESOURCE__1]\n})], HeaderComponent);\nexport { HeaderComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}